(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{510:function(t,v,_){"use strict";_.r(v);var T=_(28),s=Object(T.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[t._v("http1.1和http2.0")]),t._v(" "),_("h4",{attrs:{id:"http1-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http1-1"}},[t._v("#")]),t._v(" http1.1")]),t._v(" "),_("ul",[_("li",[t._v("HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。")]),t._v(" "),_("li",[t._v("持久连接虽然能减少 TCP 的建立和断开次数，但是它"),_("strong",[t._v("需要等待前面的请求返回之后，才能进行下一次请求")]),t._v("。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。")]),t._v(" "),_("li",[t._v("提供虚拟主机的支持。在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。因此，HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。")]),t._v(" "),_("li",[t._v("对动态生成的内容提供了完美支持。\n在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。")]),t._v(" "),_("li",[t._v("客户端 Cookie、安全机制")])]),t._v(" "),_("h4",{attrs:{id:"http2-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2-0"}},[t._v("#")]),t._v(" http2.0")]),t._v(" "),_("p",[t._v("我们知道 HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式：")]),t._v(" "),_("ol",[_("li",[t._v("增加了持久连接；")]),t._v(" "),_("li",[t._v("浏览器为每个域名最多同时维护 6 个 TCP 持久连接；")]),t._v(" "),_("li",[t._v("使用 CDN 的实现域名分片机制。")])]),t._v(" "),_("p",[t._v("http1.1的问题")]),t._v(" "),_("p",[_("strong",[t._v("第一个原因，TCP 的慢启动。")])]),t._v(" "),_("p",[_("strong",[t._v("第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。")])]),t._v(" "),_("p",[t._v("因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。")]),t._v(" "),_("p",[_("strong",[t._v("第三个原因，HTTP/1.1 队头阻塞的问题。")])]),t._v(" "),_("h4",{attrs:{id:"http-2-的多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-2-的多路复用"}},[t._v("#")]),t._v(" HTTP/2 的多路复用")]),t._v(" "),_("p",[t._v("HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。")]),t._v(" "),_("p",[t._v("另外，就是队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。")]),t._v(" "),_("p",[t._v("所以，HTTP/2 的解决方案可以总结为：一个域名只使用一个 TCP 长连接和消除队头阻塞问题。可以参考下图：")]),t._v(" "),_("html",[_("img",{attrs:{src:t.$withBase("/jsImg/yx/http1.png")}})]),t._v(" "),_("p",[t._v("从图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。")]),t._v(" "),_("p",[t._v("之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。")]),t._v(" "),_("h5",{attrs:{id:"多路复用的实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多路复用的实现"}},[t._v("#")]),t._v(" 多路复用的实现")]),t._v(" "),_("html",[_("img",{attrs:{src:t.$withBase("/jsImg/yx/http2.png")}})]),t._v(" "),_("p",[t._v("从图中可以看出，HTTP/2 添加了一个二进制分帧层，那我们就结合图来分析下 HTTP/2 的请求和接收过程。")]),t._v(" "),_("ul",[_("li",[t._v("首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。")]),t._v(" "),_("li",[t._v("这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。")]),t._v(" "),_("li",[t._v("服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。")]),t._v(" "),_("li",[t._v("然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。")]),t._v(" "),_("li",[t._v("同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。")]),t._v(" "),_("li",[t._v("浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。")])]),t._v(" "),_("h5",{attrs:{id:"http-2-其他特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-2-其他特性"}},[t._v("#")]),t._v(" HTTP/2 其他特性")]),t._v(" "),_("p",[_("strong",[t._v("1. 可以设置请求的优先级")])]),t._v(" "),_("p",[t._v("HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。")]),t._v(" "),_("p",[_("strong",[t._v("2. 服务器推送")])]),t._v(" "),_("p",[t._v("除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。")]),t._v(" "),_("p",[_("strong",[t._v("3. 头部压缩")])]),t._v(" "),_("p",[t._v("无论是 HTTP/1.1 还是 HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP/2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候（get请求），基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。")])])}),[],!1,null,null,null);v.default=s.exports}}]);